import std.algorithm, std.traits, std.uni, std.conv,
       std.range, std.array, std.exception, std.string,
       std.stdio;
import std.file : readText;
import std.d.lexer, std.d.parser, std.d.ast, std.d.formatter;

//import clWrap.types;;

void doNothing(string, size_t, size_t, string, bool) {}

void main(string[] args)
{
    auto codeData = cast(ubyte[]) readText(args[1]);

    auto cache = StringCache(StringCache.defaultBucketCount);
    LexerConfig config;
    config.stringBehavior = StringBehavior.source;
    auto tokens = getTokensForParser(codeData, config, &cache);

    auto mod = parseModule(tokens, args[1], null, &doNothing);

    auto visitor = new FuncAliasPrinter;

    writeln("//This is an autogenerated file, do not edit\n");
    writeln("module clWrap.l1.functions;\n");
    writeln("import clWrap.l1.types, derelict.opencl.cl;");
    writeln("nothrow:\n");
    visitor.visit(mod);
}

auto strip_cl(R)(R r)
{
    import std.regex;
    static reg = ctRegex!(`cl_`,"g");
    return r.replaceAll(reg, "");
}

static alphabet =
    "abcdefghijklmnopqrstuvwxyz".map!(to!string).array;

class FuncAliasPrinter : ASTVisitor
{
    bool inFunction = false;
    //size_t alphaIndex = 0;
    string[] argTypes;
    size_t funcIdx = size_t.max;;
    string retType;

    override void visit(const AliasDeclaration aliasDec)
    {
        //writeln("alias    ");
        aliasDec.accept(this);
    }

    override void visit(const IdentifierList identifiers)
    {
        static import std.ascii;

        auto app = appender!(char[])();
        format(app, identifiers.identifiers[0]);
        if (app.data.startsWith("da_cl"))
        {
            auto origName = app.data[3..$];
            auto funcName = app.data[5..$].dup;
            funcName[0] = std.ascii.toLower(funcName[0]);

            if (funcIdx != size_t.max)
            {
                writeln("extern(System) alias ", funcName, "_FuncAlias = ",
                        argTypes[funcIdx] ~ ";");
                argTypes[funcIdx] = cast(string)(funcName ~ "_FuncAlias");
            }

            writeln("auto ", funcName, "(",
                    zip(argTypes.map!strip_cl, alphabet)
                        .map!(s => s[0] ~ ' ' ~ s[1])
                        .joiner(", "), ")");
            writeln("{\n    debug assert(", origName, ");");
            writeln("    auto ret = cast(" ~ retType.strip_cl() ~ ")", origName, "(", 
                    zip(argTypes, alphabet)
                        .map!(s => "cast(" ~ s[0] ~ ')' ~ s[1])
                        .joiner(", "), ");");
            writeln("    return ret;\n}\n");
        }
    }

    override void visit(const Type type)
    {
        auto idx = type.typeSuffixes
            .countUntil!((t) => t.delegateOrFunction == tok!"function");

        if (inFunction)
        {
            auto app = appender!string();
            format(app, type);
            argTypes ~= app.data;
            if (idx != -1) funcIdx = argTypes.length - 1;
        }
        if (!inFunction)
        {
            if(idx != -1)
            {
                inFunction = true;
                argTypes = [];
                funcIdx = size_t.max;
                
                auto app = appender!string();
                format(app, type);
                retType = app.data.until(" function").to!string;
                //alphaIndex = 0;

                type.accept(this);
                
                inFunction = false;
            }
        }
    }
    
    alias visit = ASTVisitor.visit;
}
